{% extends "base.html" %}

{% block content %}
<div class="bg-white rounded-lg shadow-sm p-6">
    {% if error %}
    <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4" role="alert">
        <strong class="font-bold">é”™è¯¯ï¼</strong>
        <span class="block sm:inline">{{ error }}</span>
    </div>
    {% endif %}

    <!-- Tabs -->
    <div class="border-b border-gray-200 mb-6">
        <div class="flex -mb-px">
            <button onclick="showTab('unpublished')" id="unpublished-tab-button" class="tab-button mr-4 py-2 px-4 border-b-2 border-indigo-500 text-indigo-600 font-medium">
                æœªå‘å¸ƒ
            </button>
            <button onclick="showTab('published')" id="published-tab-button" class="tab-button py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700 font-medium">
                å·²å‘å¸ƒ
            </button>
            <button onclick="showTab('scheduled')" id="scheduled-tab-button" class="tab-button py-2 px-4 border-b-2 border-transparent text-gray-500 hover:text-gray-700 font-medium">
                é¢„çº¦å‘å¸ƒ
            </button>
        </div>
    </div>

    <!-- æœªå‘å¸ƒ Tab -->
    <div id="unpublished-tab" class="tab-content">
        <div class="mb-4 flex justify-between items-center">
            <div class="flex items-center space-x-4">
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="schedule_publish" class="sr-only peer" onchange="toggleScheduleTime(this)">
                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    <span class="ml-3 text-sm font-medium text-gray-900">é¢„çº¦å‘å¸ƒ</span>
                </label>
                
                <div id="schedule_time_container" class="hidden">
                    <input type="datetime-local" 
                           id="schedule_time" 
                           class="rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-sm"
                           ondblclick="this.readOnly=false"
                           onblur="this.readOnly=true">
                </div>

                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="add_product_toggle" class="sr-only peer">
                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-green-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-600"></div>
                    <span class="ml-3 text-sm font-medium text-gray-900">æ·»åŠ å•†å“</span>
                </label>

                <!-- å…¨å±€æ¨¡å¼é€‰æ‹© -->
                <div class="flex items-center space-x-2">
                    <span class="text-sm font-medium text-gray-900">é»˜è®¤æ¨¡å¼:</span>
                    <div class="flex space-x-1">
                        <button id="global-insert-btn" onclick="setGlobalMode('insert')" 
                                class="global-mode-btn px-2 py-1 text-xs rounded bg-gray-200 text-gray-700 hover:bg-gray-300">
                            æ’å…¥
                        </button>
                        <button id="global-random-btn" onclick="setGlobalMode('random')" 
                                class="global-mode-btn px-2 py-1 text-xs rounded bg-green-500 text-white">
                            éšæœº
                        </button>
                        <button id="global-overlay-btn" onclick="setGlobalMode('overlay')" 
                                class="global-mode-btn px-2 py-1 text-xs rounded bg-gray-200 text-gray-700 hover:bg-gray-300">
                            è¦†ç›–
                        </button>
                    </div>
                </div>

                <!-- çŠ¶æ€æŒ‡ç¤ºå™¨ -->
                <div class="flex items-center">
                    <span class="text-xs px-2 py-1 rounded bg-blue-100 text-blue-800" id="template-status">
                        æœªæŒ‡å®šæ¨¡æ¿
                    </span>
                </div>

                <button onclick="fetchEmailMaterials()" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700">
                    è·å–é‚®ç®±ç´ æ
                </button>
            </div>
            <button onclick="publishSelected()" class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700">
                ä¸€é”®å‘å¸ƒ
            </button>
        </div>
        <div class="overflow-x-auto">
            <table class="min-w-full divide-y divide-gray-200">
                <thead>
                    <tr class="bg-gray-50">
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-10">
                            <div class="flex items-center">
                                <input type="checkbox" id="select-all" onchange="toggleSelectAll(this)">
                                <span class="selection-order ml-2 hidden"></span>
                            </div>
                        </th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer" onclick="sortMaterials('title')">
                            ç´ ææ ‡é¢˜
                            <span id="sort-title" class="ml-1"></span>
                        </th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">é‚®ä»¶æ ‡é¢˜</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">å›¾ç‰‡æ•°é‡</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer" onclick="sortMaterials('accountType')">
                            è´¦å·åç§°
                            <span id="sort-accountType" class="ml-1"></span>
                        </th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">æ“ä½œ</th>
                    </tr>
                </thead>
                <tbody id="unpublished-list" class="bg-white divide-y divide-gray-200">
                    <!-- åŠ¨æ€å†…å®¹å°†ç”± JavaScript å¡«å…… -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- å·²å‘å¸ƒ Tab -->
    <div id="published-tab" class="tab-content hidden">
        <div class="mb-4 flex justify-between items-center">
            <div class="flex space-x-2">
                <button onclick="batchReturnToUnpublished()" class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700">
                    ä¸€é”®è¿”å›
                </button>
                <button onclick="batchClearPublished()" class="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700">
                    ä¸€é”®æ¸…ç©º
                </button>
            </div>
        </div>
        <div class="overflow-x-auto">
            <table class="min-w-full divide-y divide-gray-200">
                <thead>
                    <tr class="bg-gray-50">
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-10">
                            <input type="checkbox" id="select-all-published" onchange="toggleSelectAllPublished(this)">
                        </th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ç´ ææ ‡é¢˜</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">å›¾ç‰‡æ•°é‡</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">å‘å¸ƒæ—¶é—´</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">è´¦å·åç§°</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">çŠ¶æ€</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">æ“ä½œ</th>
                    </tr>
                </thead>
                <tbody id="published-list" class="bg-white divide-y divide-gray-200">
                    <!-- åŠ¨æ€å†…å®¹å°†ç”± JavaScript å¡«å…… -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- é¢„çº¦å‘å¸ƒ Tab -->
    <div id="scheduled-tab" class="tab-content hidden">
        <div class="mb-4 flex justify-between items-center">
            <div class="flex space-x-2">
                <button onclick="batchCancelScheduled()" class="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700">
                    å–æ¶ˆé¢„çº¦
                </button>
            </div>
        </div>
        <div class="overflow-x-auto">
            <table class="min-w-full divide-y divide-gray-200">
                <thead>
                    <tr class="bg-gray-50">
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-10">
                            <input type="checkbox" id="select-all-scheduled" onchange="toggleSelectAllScheduled(this)">
                        </th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ç´ ææ ‡é¢˜</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">å›¾ç‰‡æ•°é‡</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">é¢„çº¦æ—¶é—´</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">è´¦å·åç§°</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">çŠ¶æ€</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">æ“ä½œ</th>
                    </tr>
                </thead>
                <tbody id="scheduled-list" class="bg-white divide-y divide-gray-200">
                    <!-- åŠ¨æ€å†…å®¹å°†ç”± JavaScript å¡«å…… -->
                </tbody>
            </table>
        </div>
    </div>
</div>

<script>
let materialsData = {
    materials: {{ unpublished_materials | tojson | safe }},
    accounts: {{ accounts | tojson | safe }}
};
let publishedData = {{ published_materials | tojson | safe }};
let scheduledData = {{ scheduled_materials | tojson | safe }};

let selectedMaterials = new Set();
let currentSort = { column: null, direction: 'asc' };
let regionAccountMapping = {}; // åœ°åŒºè´¦å·æ˜ å°„å…³ç³»

// WebSocketè¿æ¥ç®¡ç†
let websocket = null;
let templateIframe = null; // éšå½¢æ¨¡æ¿é¡µé¢iframe

// ç¡®ä¿æ¨¡æ¿é¡µé¢iframeå­˜åœ¨å¹¶å¯ç”¨
async function ensureTemplateIframe() {
    if (!templateIframe) {
        console.log('ğŸ”§ åˆ›å»ºéšå½¢æ¨¡æ¿é¡µé¢iframe...');
        templateIframe = document.createElement('iframe');
        templateIframe.src = '/template-materials';
        templateIframe.style.display = 'none';
        templateIframe.style.width = '0';
        templateIframe.style.height = '0';
        templateIframe.style.border = 'none';
        document.body.appendChild(templateIframe);
        
        // ç­‰å¾…iframeåŠ è½½å®Œæˆ
        return new Promise((resolve) => {
            templateIframe.onload = () => {
                console.log('âœ… éšå½¢æ¨¡æ¿é¡µé¢iframeåŠ è½½å®Œæˆ');
                // ç­‰å¾…é¢å¤–æ—¶é—´ç¡®ä¿WebSocketè¿æ¥å»ºç«‹
                setTimeout(resolve, 3000);
            };
        });
    }
    return Promise.resolve();
}

// åˆå§‹åŒ–WebSocketè¿æ¥
function initWebSocket() {
    console.log('ğŸ”— å°çº¢ä¹¦é¡µé¢åˆå§‹åŒ–WebSocketè¿æ¥...');
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/canvas`;
    
    websocket = new WebSocket(wsUrl);
    
    websocket.onopen = function(event) {
        console.log('âœ… å°çº¢ä¹¦é¡µé¢WebSocketè¿æ¥å·²å»ºç«‹');
        websocket.send('xiaohongshu_page_connected');
    };
    
    websocket.onmessage = function(event) {
        console.log('ğŸ“¨ å°çº¢ä¹¦é¡µé¢æ”¶åˆ°WebSocketæ¶ˆæ¯:', event.data);
        try {
            const message = JSON.parse(event.data);
            console.log('ğŸ“¨ è§£æåçš„æ¶ˆæ¯:', message);
            if (message.type === 'generate_canvas') {
                console.log('ğŸ¯ å¼€å§‹å¤„ç†Canvasç”Ÿæˆè¯·æ±‚');
                handleCanvasGenerationRequest(message);
            } else {
                console.log('â„¹ï¸ å¿½ç•¥éCanvasç”Ÿæˆæ¶ˆæ¯:', message.type);
            }
        } catch (e) {
            console.error('âŒ è§£æWebSocketæ¶ˆæ¯å¤±è´¥:', e);
            console.log('åŸå§‹æ¶ˆæ¯æ•°æ®:', event.data);
        }
    };
    
    websocket.onclose = function(event) {
        console.log('âŒ å°çº¢ä¹¦é¡µé¢WebSocketè¿æ¥å·²å…³é—­ï¼Œ5ç§’åé‡è¿...');
        setTimeout(initWebSocket, 5000);
    };
    
    websocket.onerror = function(error) {
        console.error('âŒ å°çº¢ä¹¦é¡µé¢WebSocketé”™è¯¯:', error);
    };
}

// å¤„ç†Canvasç”Ÿæˆè¯·æ±‚ - å§”æ‰˜ç»™æ¨¡æ¿é¡µé¢
async function handleCanvasGenerationRequest(message) {
    console.log('ğŸ¨ å°çº¢ä¹¦é¡µé¢æ”¶åˆ°Canvasç”Ÿæˆè¯·æ±‚:', message);
    console.log('ğŸ” è¯·æ±‚å‚æ•°:', {
        request_id: message.request_id,
        template_id: message.template_id,
        mode: message.mode,
        texts: message.texts,
        output_path: message.output_path
    });
    
    try {
        // ç¡®ä¿æ¨¡æ¿é¡µé¢iframeå­˜åœ¨
        await ensureTemplateIframe();
        console.log('âœ… æ¨¡æ¿é¡µé¢iframeå·²å°±ç»ªï¼Œå§”æ‰˜Canvasç”Ÿæˆ...');
        
        // ç›´æ¥è¿”å›å¤±è´¥ï¼Œè®©åç«¯é‡æ–°å‘é€ç»™æ¨¡æ¿é¡µé¢çš„WebSocket
        if (websocket && websocket.readyState === WebSocket.OPEN) {
            websocket.send(JSON.stringify({
                type: 'canvas_generation_complete',
                request_id: message.request_id,
                success: false,
                error: 'Delegated to template iframe'
            }));
        }
        
        return;
        
        // åˆ›å»ºéšè—çš„Canvaså…ƒç´ 
        let canvas = document.getElementById('hidden-canvas');
        if (!canvas) {
            canvas = document.createElement('canvas');
            canvas.id = 'hidden-canvas';
            canvas.width = 300;
            canvas.height = 400;
            canvas.style.display = 'none';
            document.body.appendChild(canvas);
        }
        
        // è·å–æ¨¡æ¿ä¿¡æ¯
        console.log(`ğŸ” è·å–æ¨¡æ¿ä¿¡æ¯: template_id=${template_id}`);
        const templateResponse = await fetch(`/api/template-materials/image-templates/${template_id}`);
        const templateData = await templateResponse.json();
        
        if (!templateData.success) {
            console.error('âŒ è·å–æ¨¡æ¿ä¿¡æ¯å¤±è´¥:', templateData);
            return;
        }
        
        const template = templateData.template;
        console.log('âœ… æ¨¡æ¿ä¿¡æ¯:', template);
        
        // è°ƒç”¨æ¨¡æ¿åˆ¶ä½œAPIè·å–å®Œæ•´çš„æ¨¡æ¿é…ç½®
        console.log('ğŸ”„ è·å–æ¨¡æ¿å®Œæ•´é…ç½®...', {
            material_id: parseInt(message.material_id) || 1,
            template_id: parseInt(template_id),
            texts: texts,
            mode: mode,
            output_path: output_path
        });
        
        try {
            const apiResponse = await fetch('/api/template-materials/generate-canvas-image', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    material_id: parseInt(message.material_id) || 1,
                    template_id: parseInt(template_id),
                    texts: texts,
                    mode: mode,
                    output_path: output_path
                })
            });
            
            console.log('âœ… APIå“åº”çŠ¶æ€:', apiResponse.status, apiResponse.statusText);
            
            if (!apiResponse.ok) {
                const errorText = await apiResponse.text();
                console.error('âŒ APIè°ƒç”¨å¤±è´¥:', errorText);
                throw new Error(`APIè°ƒç”¨å¤±è´¥ ${apiResponse.status}: ${errorText}`);
            }
            
            const apiResult = await apiResponse.json();
            console.log('âœ… è·å–åˆ°å®Œæ•´æ¨¡æ¿é…ç½®:', apiResult);
            
            // ä½¿ç”¨å®Œæ•´é…ç½®ç”ŸæˆCanvaså›¾ç‰‡
            const fullTemplate = apiResult.template;
            await generateCanvasWithFullTemplate(canvas, fullTemplate, texts, mode, source_image);
            
        } catch (fetchError) {
            console.error('âŒ Fetchè¯·æ±‚å¤±è´¥:', fetchError);
            throw fetchError;
        }
        
        // è½¬æ¢ä¸ºBase64å¹¶ä¿å­˜
        canvas.toBlob(async function(blob) {
            try {
                const reader = new FileReader();
                reader.onloadend = async function() {
                    const base64data = reader.result;
                    
                    // å‘é€ç»™åç«¯ä¿å­˜
                    const response = await fetch('/api/template-materials/save-generated-image', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            image_data: base64data,
                            output_path: output_path
                        })
                    });
                    
                    if (response.ok) {
                        console.log(`âœ… å°çº¢ä¹¦é¡µé¢Canvaså›¾ç‰‡å·²ä¿å­˜: ${output_path}`);
                        
                        // é€šçŸ¥åç«¯ç”ŸæˆæˆåŠŸ
                        if (websocket && websocket.readyState === WebSocket.OPEN) {
                            websocket.send(JSON.stringify({
                                type: 'canvas_generation_complete',
                                request_id: request_id,
                                success: true,
                                output_path: output_path
                            }));
                            console.log(`âœ… é€šçŸ¥åç«¯Canvasç”ŸæˆæˆåŠŸ: ${request_id}`);
                        }
                    } else {
                        console.error('âŒ ä¿å­˜Canvaså›¾ç‰‡å¤±è´¥:', await response.text());
                        
                        // é€šçŸ¥åç«¯ç”Ÿæˆå¤±è´¥
                        if (websocket && websocket.readyState === WebSocket.OPEN) {
                            websocket.send(JSON.stringify({
                                type: 'canvas_generation_complete',
                                request_id: request_id,
                                success: false,
                                error: await response.text()
                            }));
                        }
                    }
                };
                reader.readAsDataURL(blob);
                
            } catch (error) {
                console.error('âŒ å¤„ç†Canvaså›¾ç‰‡å¤±è´¥:', error);
            }
        }, 'image/jpeg', 0.95);
        
    } catch (error) {
        console.error('âŒ å¤„ç†Canvasç”Ÿæˆè¯·æ±‚å¤±è´¥:', error);
        
        // é€šçŸ¥åç«¯ç”Ÿæˆå¤±è´¥
        if (websocket && websocket.readyState === WebSocket.OPEN) {
            websocket.send(JSON.stringify({
                type: 'canvas_generation_complete',
                request_id: message.request_id,
                success: false,
                error: error.message || 'æœªçŸ¥é”™è¯¯'
            }));
        }
    }
}

// ä½¿ç”¨å®Œæ•´æ¨¡æ¿é…ç½®ç”ŸæˆCanvaså›¾ç‰‡
async function generateCanvasWithFullTemplate(canvas, template, texts, mode, sourceImage) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    console.log(`ğŸ¨ ä½¿ç”¨å®Œæ•´æ¨¡æ¿é…ç½®ç”ŸæˆCanvas: mode=${mode}`);
    console.log('æ¨¡æ¿é…ç½®:', template);
    
    // æ¸…ç©ºç”»å¸ƒ
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, width, height);
    
    // æ ¹æ®æ¨¡æ¿é…ç½®ç»˜åˆ¶èƒŒæ™¯
    await drawFullBackground(ctx, template, width, height);
    
    // å¦‚æœæ˜¯è¦†ç›–æ¨¡å¼ï¼Œå…ˆç»˜åˆ¶æºå›¾ç‰‡
    if (mode === 'overlay' && sourceImage) {
        await drawSourceImage(ctx, sourceImage, width, height);
    }
    
    // æ ¹æ®æ¨¡æ¿é…ç½®ç»˜åˆ¶æ–‡å­—
    drawFullTexts(ctx, template, texts, width, height);
    
    console.log('âœ… å®Œæ•´Canvaså›¾ç‰‡ç”Ÿæˆå®Œæˆ');
}

// å®Œæ•´èƒŒæ™¯ç»˜åˆ¶å‡½æ•°
async function drawFullBackground(ctx, template, width, height) {
    const bgStyle = template.background_style || 'minimal_gradient';
    console.log(`ğŸ¨ ç»˜åˆ¶å®Œæ•´èƒŒæ™¯: ${bgStyle}`);
    
    // å®ç°æ‰€æœ‰èƒŒæ™¯æ ·å¼
    switch (bgStyle) {
        case 'minimal_gradient':
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, '#f8f9fa');
            gradient.addColorStop(1, '#e9ecef');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            break;
        case 'clean_solid':
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);
            break;
        case 'subtle_texture':
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(0, 0, width, height);
            // æ·»åŠ å¾®å¦™çº¹ç†
            for (let i = 0; i < 200; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.05})`;
                ctx.fillRect(Math.random() * width, Math.random() * height, 1, 1);
            }
            break;
        case 'marble_texture':
            const marbleGradient = ctx.createLinearGradient(0, 0, width, height);
            marbleGradient.addColorStop(0, '#f8f8f8');
            marbleGradient.addColorStop(0.5, '#e8e8e8');
            marbleGradient.addColorStop(1, '#d8d8d8');
            ctx.fillStyle = marbleGradient;
            ctx.fillRect(0, 0, width, height);
            break;
        default:
            // é»˜è®¤èƒŒæ™¯
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);
    }
}

// å®Œæ•´æ–‡å­—ç»˜åˆ¶å‡½æ•°
function drawFullTexts(ctx, template, texts, width, height) {
    const centerX = width / 2;
    const centerY = height / 2;
    const fontSize = template.font_size || 24;
    const lineHeight = template.line_height || 1.2;
    const textStyle = template.text_style || 'gold';
    const textLines = template.text_lines || 3;
    
    console.log(`ğŸ¨ ç»˜åˆ¶å®Œæ•´æ–‡å­—: style=${textStyle}, size=${fontSize}`);
    
    // é™åˆ¶æ–‡æœ¬è¡Œæ•°
    const displayTexts = texts.slice(0, textLines);
    const lineSpacing = fontSize * lineHeight;
    const totalHeight = (displayTexts.length - 1) * lineSpacing;
    const startY = centerY - totalHeight / 2;
    
    // æ ¹æ®æ–‡å­—æ ·å¼ç»˜åˆ¶
    switch (textStyle) {
        case 'gold':
            drawGoldTextStyle(ctx, displayTexts, centerX, startY, lineSpacing, fontSize);
            break;
        case 'handwritten_elegant':
            drawHandwrittenStyle(ctx, displayTexts, centerX, startY, lineSpacing, fontSize, 'elegant');
            break;
        default:
            drawGoldTextStyle(ctx, displayTexts, centerX, startY, lineSpacing, fontSize);
    }
    
    // ç»˜åˆ¶é®ç½©
    const maskOpacity = template.mask_opacity || 0;
    if (maskOpacity > 0) {
        ctx.fillStyle = `rgba(0, 0, 0, ${maskOpacity})`;
        ctx.fillRect(0, 0, width, height);
    }
}

// é‡‘è‰²æ–‡å­—æ ·å¼
function drawGoldTextStyle(ctx, texts, centerX, startY, lineSpacing, fontSize) {
    ctx.font = `bold ${fontSize}px Arial, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    texts.forEach((text, i) => {
        const y = startY + i * lineSpacing;
        
        // é‡‘è‰²æ¸å˜
        const gradient = ctx.createLinearGradient(0, y - fontSize/2, 0, y + fontSize/2);
        gradient.addColorStop(0, '#FFD700');
        gradient.addColorStop(0.5, '#FFA500');
        gradient.addColorStop(1, '#FF8C00');
        
        ctx.fillStyle = gradient;
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 2;
        ctx.strokeText(text, centerX, y);
        ctx.fillText(text, centerX, y);
        
        // é˜´å½±æ•ˆæœ
        ctx.shadowColor = 'rgba(139, 69, 19, 0.5)';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
    });
    
    ctx.shadowColor = 'transparent';
}

// æ‰‹å†™ä½“æ ·å¼
function drawHandwrittenStyle(ctx, texts, centerX, startY, lineSpacing, fontSize, variant) {
    ctx.font = `italic bold ${fontSize}px cursive`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    texts.forEach((text, i) => {
        const y = startY + i * lineSpacing;
        ctx.fillStyle = '#2c3e50';
        ctx.fillText(text, centerX, y);
    });
}

// ç®€åŒ–çš„Canvaså›¾ç‰‡ç”Ÿæˆå‡½æ•°
async function generateCanvasImage(canvas, template, texts, mode, sourceImage) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    console.log(`ğŸ¨ å¼€å§‹ç”ŸæˆCanvaså›¾ç‰‡: mode=${mode}`);
    
    // æ¸…ç©ºç”»å¸ƒ
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, width, height);
    
    // ç»˜åˆ¶èƒŒæ™¯
    await drawBackground(ctx, template, width, height);
    
    // å¦‚æœæ˜¯è¦†ç›–æ¨¡å¼ï¼Œå…ˆç»˜åˆ¶æºå›¾ç‰‡
    if (mode === 'overlay' && sourceImage) {
        await drawSourceImage(ctx, sourceImage, width, height);
    }
    
    // ç»˜åˆ¶æ–‡å­—
    drawTexts(ctx, template, texts, width, height);
    
    console.log('âœ… Canvaså›¾ç‰‡ç”Ÿæˆå®Œæˆ');
}

// ç»˜åˆ¶èƒŒæ™¯
async function drawBackground(ctx, template, width, height) {
    const bgStyle = template.background_style || 'minimal_gradient';
    console.log(`ğŸ¨ ç»˜åˆ¶èƒŒæ™¯: ${bgStyle}`);
    
    // å®ç°ä¸»è¦çš„èƒŒæ™¯æ ·å¼
    switch (bgStyle) {
        case 'minimal_gradient':
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#f8f9fa');
            gradient.addColorStop(1, '#e9ecef');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            break;
            
        case 'marble_texture':
            const marbleGradient = ctx.createLinearGradient(0, 0, 0, height);
            marbleGradient.addColorStop(0, '#f8f8f8');
            marbleGradient.addColorStop(1, '#e8e8e8');
            ctx.fillStyle = marbleGradient;
            ctx.fillRect(0, 0, width, height);
            break;
            
        default:
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(0, 0, width, height);
    }
}

// ç»˜åˆ¶æºå›¾ç‰‡ï¼ˆè¦†ç›–æ¨¡å¼ï¼‰
async function drawSourceImage(ctx, sourceImagePath, width, height) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = function() {
            // è°ƒæ•´ä¸ºæ­£æ–¹å½¢
            const minSize = Math.min(img.width, img.height);
            const cropX = (img.width - minSize) / 2;
            const cropY = (img.height - minSize) / 2;
            
            ctx.drawImage(img, cropX, cropY, minSize, minSize, 0, 0, width, height);
            resolve();
        };
        img.onerror = reject;
        img.src = sourceImagePath;
    });
}

// ç»˜åˆ¶æ–‡å­—
function drawTexts(ctx, template, texts, width, height) {
    const fontSize = template.font_size || 40;
    const lineHeight = parseFloat(template.line_height || '1.2');
    const textStyle = template.text_style || 'gold';
    
    console.log(`ğŸ”¤ ç»˜åˆ¶æ–‡å­—: style=${textStyle}, size=${fontSize}`);
    
    // è®¾ç½®å­—ä½“
    ctx.font = `bold ${fontSize}px Arial, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // è®¡ç®—æ–‡å­—ä½ç½®
    const centerX = width / 2;
    const centerY = height / 2;
    const spacing = fontSize * lineHeight;
    const totalHeight = (texts.length - 1) * spacing;
    const startY = centerY - totalHeight / 2;
    
    // æ ¹æ®æ–‡å­—æ ·å¼è®¾ç½®é¢œè‰²å’Œæ•ˆæœ
    if (textStyle === 'gold') {
        // é‡‘è‰²æ ·å¼ï¼šæ£•è‰²æè¾¹ + é‡‘è‰²å¡«å……
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 3;
        ctx.fillStyle = '#DAA520';
    } else {
        // é»˜è®¤æ ·å¼ï¼šæ·±è‰²æ–‡å­—
        ctx.fillStyle = '#2c3e50';
    }
    
    // ç»˜åˆ¶æ¯è¡Œæ–‡å­—
    texts.forEach((text, index) => {
        const y = startY + index * spacing;
        
        if (textStyle === 'gold') {
            // å…ˆæè¾¹å†å¡«å……
            ctx.strokeText(text, centerX, y);
            ctx.fillText(text, centerX, y);
        } else {
            ctx.fillText(text, centerX, y);
        }
        
        console.log(`âœ… ç»˜åˆ¶æ–‡å­—: "${text}" ä½ç½®=(${centerX}, ${y})`);
    });
}

// é¡µé¢åŠ è½½æ—¶è·å–åœ°åŒºæ˜ å°„å…³ç³»
document.addEventListener('DOMContentLoaded', function() {
    // åˆå§‹åŒ–WebSocketè¿æ¥ä»¥æ”¯æŒæ¨¡æ¿ç”Ÿæˆ
    initWebSocket();
    
    // é¢„å…ˆåˆ›å»ºæ¨¡æ¿é¡µé¢iframe
    setTimeout(() => {
        ensureTemplateIframe().then(() => {
            console.log('ğŸ¯ éšå½¢æ¨¡æ¿é¡µé¢é¢„åŠ è½½å®Œæˆ');
        });
    }, 2000); // ç­‰å¾…2ç§’ååŠ è½½ï¼Œé¿å…å½±å“ä¸»é¡µé¢
    
    loadRegionMapping();
    showTab('unpublished');
});

// è·å–åœ°åŒºæ˜ å°„å…³ç³»
async function loadRegionMapping() {
    try {
        const response = await fetch('/api/xiaohongshu-settings/config');
        const data = await response.json();
        
        if (data.settings && data.settings.region_account_mapping) {
            regionAccountMapping = data.settings.region_account_mapping;
            console.log('åŠ è½½åœ°åŒºæ˜ å°„å…³ç³»:', regionAccountMapping);
        }
    } catch (error) {
        console.error('åŠ è½½åœ°åŒºæ˜ å°„å…³ç³»å¤±è´¥:', error);
    }
}

// æ ¹æ®ç´ ææ ‡é¢˜åŒ¹é…è´¦å·ID
function getAccountIdByTitle(title) {
    for (const [regions, accountId] of Object.entries(regionAccountMapping)) {
        const regionList = regions.split(',').map(r => r.trim());
        for (const region of regionList) {
            if (title.includes(region)) {
                console.log(`ç´ æ"${title}"åŒ¹é…åˆ°åœ°åŒº"${region}"ï¼Œè´¦å·ID: ${accountId}`);
                return accountId;
            }
        }
    }
    return null; // æ²¡æœ‰åŒ¹é…åˆ°
}

// æ˜¾ç¤ºæ ‡ç­¾é¡µ
function showTab(tabName) {
    // éšè—æ‰€æœ‰æ ‡ç­¾é¡µå†…å®¹
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.add('hidden');
    });
    
    // é‡ç½®æ‰€æœ‰æ ‡ç­¾æŒ‰é’®æ ·å¼
    document.querySelectorAll('.tab-button').forEach(button => {
        button.classList.remove('border-indigo-500', 'text-indigo-600');
        button.classList.add('border-transparent', 'text-gray-500');
    });
    
    // æ˜¾ç¤ºé€‰ä¸­çš„æ ‡ç­¾é¡µ
    document.getElementById(tabName + '-tab').classList.remove('hidden');
    document.getElementById(tabName + '-tab-button').classList.add('border-indigo-500', 'text-indigo-600');
    document.getElementById(tabName + '-tab-button').classList.remove('border-transparent', 'text-gray-500');
    
    // æ ¹æ®æ ‡ç­¾é¡µåŠ è½½ç›¸åº”æ•°æ®
    if (tabName === 'unpublished') {
        renderUnpublishedMaterials();
    } else if (tabName === 'published') {
        renderPublishedMaterials();
    } else if (tabName === 'scheduled') {
        renderScheduledMaterials();
    }
}

// åˆ‡æ¢é¢„çº¦æ—¶é—´è¾“å…¥æ¡†æ˜¾ç¤º
function toggleScheduleTime(checkbox) {
    const container = document.getElementById('schedule_time_container');
    if (checkbox.checked) {
        container.classList.remove('hidden');
    } else {
        container.classList.add('hidden');
    }
}

// æ¸²æŸ“æœªå‘å¸ƒç´ æ
function renderUnpublishedMaterials() {
    const tbody = document.getElementById('unpublished-list');
    tbody.innerHTML = '';
    
    materialsData.materials.forEach(material => {
        const row = document.createElement('tr');
        
        // å…ˆå°è¯•æ ¹æ®åœ°åŒºæ˜ å°„åŒ¹é…è´¦å·ï¼Œå¦‚æœæ²¡æœ‰æ˜ å°„è´¦å·åˆ™ä½¿ç”¨åŸæœ‰çš„è´¦å·
        let selectedAccountId = material.account_id;
        if (!selectedAccountId) {
            const mappedAccountId = getAccountIdByTitle(material.title);
            if (mappedAccountId) {
                selectedAccountId = mappedAccountId;
                // è‡ªåŠ¨æ›´æ–°ç´ æçš„è´¦å·ï¼ˆåå°åŒæ­¥ï¼‰
                updateMaterialAccount(material.id, mappedAccountId, false);
            }
        }
        
        row.innerHTML = `
            <td class="px-6 py-4 whitespace-nowrap">
                <input type="checkbox" 
                       data-material-id="${material.id}" 
                       onchange="toggleMaterialSelection(this)"
                       class="material-checkbox">
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <div class="text-sm font-medium text-gray-900" onclick="editTitle(${material.id}, this)">${material.title}</div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <div class="text-sm text-gray-500">${material.email_subject || '-'}</div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <div class="text-sm text-gray-900">${material.image_count || 0}</div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <select onchange="updateMaterialAccount(${material.id}, this.value)" class="text-sm border-gray-300 rounded">
                    <option value="">é€‰æ‹©è´¦å·</option>
                    ${materialsData.accounts.map(account => 
                        `<option value="${account.id}" ${account.id == selectedAccountId ? 'selected' : ''}>${account.username}</option>`
                    ).join('')}
                </select>
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium">
                <button onclick="directPublish(${material.id})" class="text-indigo-600 hover:text-indigo-900 mr-2">å‘å¸ƒ</button>
                <button onclick="deleteMaterial(${material.id})" class="text-red-600 hover:text-red-900">åˆ é™¤</button>
            </td>
        `;
        tbody.appendChild(row);
    });
}

// æ¸²æŸ“å·²å‘å¸ƒç´ æ
function renderPublishedMaterials() {
    const tbody = document.getElementById('published-list');
    tbody.innerHTML = '';
    
    publishedData.forEach(material => {
        const row = document.createElement('tr');
        const publishTime = material.publish_time ? new Date(material.publish_time).toLocaleString() : '-';
        const accountName = materialsData.accounts.find(a => a.id == material.account_id)?.username || '-';
        
        row.innerHTML = `
            <td class="px-6 py-4 whitespace-nowrap">
                <input type="checkbox" 
                       data-material-id="${material.id}" 
                       class="published-checkbox">
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <div class="text-sm font-medium text-gray-900">${material.title}</div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <div class="text-sm text-gray-900">${material.image_count || 0}</div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <div class="text-sm text-gray-500">${publishTime}</div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <div class="text-sm text-gray-500">${accountName}</div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${material.publish_status === 'success' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">
                    ${material.publish_status === 'success' ? 'æˆåŠŸ' : 'å¤±è´¥'}
                </span>
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium">
                <button onclick="returnToUnpublished(${material.id})" class="text-indigo-600 hover:text-indigo-900 mr-2">è¿”å›</button>
                <button onclick="deleteMaterial(${material.id})" class="text-red-600 hover:text-red-900">åˆ é™¤</button>
            </td>
        `;
        tbody.appendChild(row);
    });
}

// æ¸²æŸ“é¢„çº¦å‘å¸ƒç´ æ
function renderScheduledMaterials() {
    const tbody = document.getElementById('scheduled-list');
    tbody.innerHTML = '';
    
    scheduledData.forEach(material => {
        const row = document.createElement('tr');
        const scheduleTime = material.schedule_time ? new Date(material.schedule_time).toLocaleString() : '-';
        const accountName = materialsData.accounts.find(a => a.id == material.account_id)?.username || '-';
        
        row.innerHTML = `
            <td class="px-6 py-4 whitespace-nowrap">
                <input type="checkbox" 
                       data-material-id="${material.id}" 
                       class="scheduled-checkbox">
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <div class="text-sm font-medium text-gray-900">${material.title}</div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <div class="text-sm text-gray-900">${material.image_count || 0}</div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <div class="text-sm text-gray-500">${scheduleTime}</div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <div class="text-sm text-gray-500">${accountName}</div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-yellow-100 text-yellow-800">
                    ${material.schedule_status === 'scheduled' ? 'å·²é¢„çº¦' : 'å¤„ç†ä¸­'}
                </span>
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium">
                <button onclick="cancelScheduled(${material.id})" class="text-red-600 hover:text-red-900 mr-2">å–æ¶ˆ</button>
                <button onclick="deleteMaterial(${material.id})" class="text-red-600 hover:text-red-900">åˆ é™¤</button>
            </td>
        `;
        tbody.appendChild(row);
    });
}

// è·å–é‚®ç®±ç´ æ
async function fetchEmailMaterials() {
    const button = event.target;
    const originalText = button.textContent;
    button.textContent = 'æ­£åœ¨è·å–...';
    button.disabled = true;
    
    try {
        const response = await fetch('/api/xiaohongshu-materials/fetch-email-materials', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || `HTTP ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            alert(`æˆåŠŸè·å– ${result.new_count} ä¸ªæ–°ç´ æ`);
            location.reload(); // é‡æ–°åŠ è½½é¡µé¢æ˜¾ç¤ºæ–°ç´ æ
        } else {
            alert('è·å–é‚®ç®±ç´ æå¤±è´¥: ' + (result.message || 'æœªçŸ¥é”™è¯¯'));
        }
    } catch (error) {
        console.error('Error:', error);
        alert('è·å–é‚®ç®±ç´ æå¤±è´¥: ' + error.message);
    } finally {
        button.textContent = originalText;
        button.disabled = false;
    }
}

// æ‰¹é‡å‘å¸ƒé€‰ä¸­çš„ç´ æ
async function publishSelected() {
    const selectedIds = Array.from(selectedMaterials);
    if (selectedIds.length === 0) {
        alert('è¯·å…ˆé€‰æ‹©è¦å‘å¸ƒçš„ç´ æ');
        return;
    }
    
    const schedulePublish = document.getElementById('schedule_publish').checked;
    const scheduleTime = document.getElementById('schedule_time').value;
    
    if (schedulePublish && !scheduleTime) {
        alert('è¯·è®¾ç½®é¢„çº¦å‘å¸ƒæ—¶é—´');
        return;
    }
    
    try {
        const response = await fetch('/api/xiaohongshu-materials/publish-batch', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                material_ids: selectedIds,
                schedule_publish: schedulePublish,
                schedule_time: scheduleTime
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            alert(result.message);
            location.reload();
        } else {
            alert('å‘å¸ƒå¤±è´¥: ' + (result.message || 'æœªçŸ¥é”™è¯¯'));
        }
    } catch (error) {
        console.error('Error:', error);
        alert('å‘å¸ƒå¤±è´¥: ' + error.message);
    }
}

// åˆ‡æ¢ç´ æé€‰æ‹©çŠ¶æ€
function toggleMaterialSelection(checkbox) {
    const materialId = parseInt(checkbox.dataset.materialId);
    if (checkbox.checked) {
        selectedMaterials.add(materialId);
    } else {
        selectedMaterials.delete(materialId);
    }
}

// å…¨é€‰/å–æ¶ˆå…¨é€‰
function toggleSelectAll(checkbox) {
    const checkboxes = document.querySelectorAll('.material-checkbox');
    selectedMaterials.clear();
    
    checkboxes.forEach(cb => {
        cb.checked = checkbox.checked;
        if (checkbox.checked) {
            selectedMaterials.add(parseInt(cb.dataset.materialId));
        }
    });
}

// åˆ é™¤ç´ æ
async function deleteMaterial(materialId) {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªç´ æå—ï¼Ÿ')) {
        return;
    }
    
    try {
        const response = await fetch(`/api/xiaohongshu-materials/${materialId}`, {
            method: 'DELETE'
        });
        
        const result = await response.json();
        
        if (result.success) {
            location.reload();
        } else {
            alert('åˆ é™¤å¤±è´¥: ' + (result.message || 'æœªçŸ¥é”™è¯¯'));
        }
    } catch (error) {
        console.error('Error:', error);
        alert('åˆ é™¤å¤±è´¥: ' + error.message);
    }
}

// æ›´æ–°ç´ æå…³è”è´¦å·
async function updateMaterialAccount(materialId, accountId, showAlert = true) {
    try {
        const response = await fetch(`/api/xiaohongshu-materials/${materialId}/account`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ account_id: parseInt(accountId) })
        });
        
        const result = await response.json();
        
        if (!result.success && showAlert) {
            alert('æ›´æ–°è´¦å·å¤±è´¥: ' + (result.message || 'æœªçŸ¥é”™è¯¯'));
        } else if (result.success && !showAlert) {
            console.log(`ç´ æ ${materialId} è‡ªåŠ¨åŒ¹é…è´¦å· ${accountId} æˆåŠŸ`);
        }
    } catch (error) {
        console.error('Error:', error);
        if (showAlert) {
            alert('æ›´æ–°è´¦å·å¤±è´¥: ' + error.message);
        }
    }
}

// æ›´æ–°ç´ ææ¨¡æ¿
async function updateMaterialTemplate(materialId, templateId) {
    try {
        const response = await fetch(`/api/xiaohongshu-materials/${materialId}/template`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ template_id: templateId ? parseInt(templateId) : null })
        });
        
        const result = await response.json();
        
        if (!result.success) {
            alert('æ›´æ–°æ¨¡æ¿å¤±è´¥: ' + (result.message || 'æœªçŸ¥é”™è¯¯'));
        } else {
            console.log(`ç´ æ ${materialId} æ¨¡æ¿æ›´æ–°æˆåŠŸ`);
            // åˆ·æ–°åˆ—è¡¨ä»¥æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            loadMaterials();
        }
    } catch (error) {
        console.error('Error:', error);
        alert('æ›´æ–°æ¨¡æ¿å¤±è´¥: ' + error.message);
    }
}

// å…¨å±€é»˜è®¤æ¨¡å¼
let globalDefaultMode = 'random';

// è®¾ç½®å…¨å±€æ¨¡å¼
async function setGlobalMode(mode) {
    globalDefaultMode = mode;
    
    // æ›´æ–°æŒ‰é’®çŠ¶æ€
    document.querySelectorAll('.global-mode-btn').forEach(btn => {
        btn.className = 'global-mode-btn px-2 py-1 text-xs rounded bg-gray-200 text-gray-700 hover:bg-gray-300';
    });
    
    const activeBtn = document.getElementById(`global-${mode}-btn`);
    if (activeBtn) {
        if (mode === 'insert') {
            activeBtn.className = 'global-mode-btn px-2 py-1 text-xs rounded bg-blue-500 text-white';
        } else if (mode === 'random') {
            activeBtn.className = 'global-mode-btn px-2 py-1 text-xs rounded bg-green-500 text-white';
        } else if (mode === 'overlay') {
            activeBtn.className = 'global-mode-btn px-2 py-1 text-xs rounded bg-orange-500 text-white';
        }
    }
    
    console.log(`å…¨å±€é»˜è®¤æ¨¡å¼è®¾ç½®ä¸º: ${mode}`);
}

// æ£€æŸ¥æ¨¡æ¿æŒ‡å®šçŠ¶æ€
async function checkTemplateStatus() {
    try {
        const response = await fetch('/api/template-materials/get-template-status');
        const result = await response.json();
        
        const statusElement = document.getElementById('template-status');
        if (statusElement) {
            if (result.success && result.has_template) {
                statusElement.textContent = 'å·²æŒ‡å®šæ¨¡æ¿';
                statusElement.className = 'text-xs px-2 py-1 rounded bg-red-100 text-red-800';
            } else {
                statusElement.textContent = 'æœªæŒ‡å®šæ¨¡æ¿';
                statusElement.className = 'text-xs px-2 py-1 rounded bg-blue-100 text-blue-800';
            }
        }
    } catch (error) {
        console.error('æ£€æŸ¥æ¨¡æ¿çŠ¶æ€å¤±è´¥:', error);
        const statusElement = document.getElementById('template-status');
        if (statusElement) {
            statusElement.textContent = 'æœªæŒ‡å®šæ¨¡æ¿';
            statusElement.className = 'text-xs px-2 py-1 rounded bg-blue-100 text-blue-800';
        }
    }
}

// æ‰¹é‡æ›´æ–°æ‰€æœ‰ç´ ææ¨¡å¼
async function batchUpdateAllMaterials(mode) {
    try {
        if (!materialsData.materials) return;
        
        const unpublishedMaterials = materialsData.materials.filter(material => 
            material.status === 'unpublished'
        );
        
        if (unpublishedMaterials.length === 0) {
            alert('æ²¡æœ‰æœªå‘å¸ƒçš„ç´ æéœ€è¦æ›´æ–°');
            return;
        }
        
        const confirmed = confirm(`ç¡®å®šè¦å°† ${unpublishedMaterials.length} ä¸ªæœªå‘å¸ƒç´ æçš„æ¨¡å¼éƒ½è®¾ç½®ä¸º ${mode === 'insert' ? 'æ’å…¥' : mode === 'overlay' ? 'è¦†ç›–' : 'éšæœº'} æ¨¡å¼å—ï¼Ÿ`);
        if (!confirmed) return;
        
        let successCount = 0;
        let failCount = 0;
        
        for (const material of unpublishedMaterials) {
            try {
                const response = await fetch(`/api/xiaohongshu-materials/${material.id}/mode`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ mode: mode })
                });
                
                const result = await response.json();
                if (result.success) {
                    successCount++;
                } else {
                    failCount++;
                }
            } catch (error) {
                failCount++;
            }
        }
        
        alert(`æ‰¹é‡æ›´æ–°å®Œæˆï¼æˆåŠŸ: ${successCount}, å¤±è´¥: ${failCount}`);
        loadMaterials();
        
    } catch (error) {
        alert('æ‰¹é‡æ›´æ–°å¤±è´¥: ' + error.message);
    }
}

// ç›´æ¥å‘å¸ƒå•ä¸ªç´ æ
async function directPublish(materialId) {
    try {
        const addProduct = document.getElementById('add_product_toggle').checked;
        
        const response = await fetch(`/api/xiaohongshu-materials/${materialId}/direct-publish`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                add_product: addProduct,
                default_mode: globalDefaultMode
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            alert('å‘å¸ƒæˆåŠŸ');
            location.reload();
        } else {
            alert('å‘å¸ƒå¤±è´¥: ' + (result.message || 'æœªçŸ¥é”™è¯¯'));
        }
    } catch (error) {
        console.error('Error:', error);
        alert('å‘å¸ƒå¤±è´¥: ' + error.message);
    }
}

// é¡µé¢åŠ è½½æ—¶é»˜è®¤æ˜¾ç¤ºæœªå‘å¸ƒæ ‡ç­¾é¡µ
document.addEventListener('DOMContentLoaded', function() {
    showTab('unpublished');
    checkTemplateStatus();
    
    // ç›‘å¬è·¨é¡µé¢çš„æ¨¡æ¿çŠ¶æ€å˜åŒ–
    window.addEventListener('storage', function(e) {
        if (e.key === 'templateStatus') {
            checkTemplateStatus();
        }
    });
    
    // ç›‘å¬åŒé¡µé¢çš„æ¨¡æ¿çŠ¶æ€å˜åŒ–
    window.addEventListener('templateStatusChanged', function() {
        checkTemplateStatus();
    });
});

// å…¶ä»–è¾…åŠ©å‡½æ•°
function sortMaterials(column) {
    // æ’åºåŠŸèƒ½å®ç°
}

function editTitle(materialId, element) {
    // ç¼–è¾‘æ ‡é¢˜åŠŸèƒ½å®ç°
}

function toggleSelectAllPublished(checkbox) {
    const checkboxes = document.querySelectorAll('.published-checkbox');
    checkboxes.forEach(cb => {
        cb.checked = checkbox.checked;
    });
}

function toggleSelectAllScheduled(checkbox) {
    const checkboxes = document.querySelectorAll('.scheduled-checkbox');
    checkboxes.forEach(cb => {
        cb.checked = checkbox.checked;
    });
}

async function returnToUnpublished(materialId) {
    if (!confirm('ç¡®å®šè¦å°†æ­¤ç´ æè¿”å›åˆ°æœªå‘å¸ƒçŠ¶æ€å—ï¼Ÿ')) {
        return;
    }
    
    try {
        const response = await fetch(`/api/xiaohongshu-materials/${materialId}/status`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ status: 'unpublished' })
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || 'è¿”å›å¤±è´¥');
        }
        
        const data = await response.json();
        if (data.success) {
            window.location.reload();
        } else {
            alert('è¿”å›å¤±è´¥ï¼š' + data.message);
        }
    } catch (error) {
        console.error('Error:', error);
        alert('æ“ä½œå¤±è´¥ï¼š' + error.message);
    }
}

async function cancelScheduled(materialId) {
    if (!confirm('ç¡®å®šè¦å–æ¶ˆé¢„çº¦å‘å¸ƒå—ï¼Ÿ')) {
        return;
    }
    
    try {
        const response = await fetch(`/api/xiaohongshu-materials/${materialId}/status`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ status: 'unpublished' })
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || 'å–æ¶ˆå¤±è´¥');
        }
        
        const data = await response.json();
        if (data.success) {
            window.location.reload();
        } else {
            alert('å–æ¶ˆå¤±è´¥ï¼š' + data.message);
        }
    } catch (error) {
        console.error('Error:', error);
        alert('æ“ä½œå¤±è´¥ï¼š' + error.message);
    }
}

async function batchReturnToUnpublished() {
    if (!confirm('ç¡®å®šè¦å°†æ‰€æœ‰å·²å‘å¸ƒçš„ç´ æè¿”å›åˆ°æœªå‘å¸ƒçŠ¶æ€å—ï¼Ÿ')) {
        return;
    }
    
    try {
        const response = await fetch('/api/xiaohongshu-materials/batch-return', {
            method: 'POST'
        });
        
        const data = await response.json();
        if (data.success) {
            window.location.reload();
        } else {
            alert('æ‰¹é‡è¿”å›å¤±è´¥ï¼š' + data.message);
        }
    } catch (error) {
        console.error('Error:', error);
        alert('æ“ä½œå¤±è´¥ï¼š' + error.message);
    }
}

async function batchClearPublished() {
    if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å·²å‘å¸ƒçš„ç´ æå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼')) {
        return;
    }
    
    try {
        const response = await fetch('/api/xiaohongshu-materials/batch-clear', {
            method: 'POST'
        });
        
        const data = await response.json();
        if (data.success) {
            window.location.reload();
        } else {
            alert('æ‰¹é‡æ¸…ç©ºå¤±è´¥ï¼š' + data.message);
        }
    } catch (error) {
        console.error('Error:', error);
        alert('æ“ä½œå¤±è´¥ï¼š' + error.message);
    }
}

async function batchCancelScheduled() {
    if (!confirm('ç¡®å®šè¦å–æ¶ˆæ‰€æœ‰é¢„çº¦å‘å¸ƒå—ï¼Ÿ')) {
        return;
    }
    
    try {
        const response = await fetch('/api/xiaohongshu-materials/batch-cancel-scheduled', {
            method: 'POST'
        });
        
        const data = await response.json();
        if (data.success) {
            window.location.reload();
        } else {
            alert('æ‰¹é‡å–æ¶ˆå¤±è´¥ï¼š' + data.message);
        }
    } catch (error) {
        console.error('Error:', error);
        alert('æ“ä½œå¤±è´¥ï¼š' + error.message);
    }
}

async function fetchEmailMaterials() {
    if (!confirm('ç¡®å®šè¦ä»é‚®ç®±è·å–æ–°çš„ç´ æå—ï¼Ÿ')) {
        return;
    }
    
    try {
        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = 'è·å–ä¸­...';
        button.disabled = true;
        
        const response = await fetch('/api/xiaohongshu-materials/fetch-email-materials', {
            method: 'POST'
        });
        
        const data = await response.json();
        
        // æ¢å¤æŒ‰é’®çŠ¶æ€
        button.textContent = originalText;
        button.disabled = false;
        
        if (data.success) {
            alert(`æˆåŠŸè·å– ${data.new_count} ä¸ªæ–°ç´ æ`);
            window.location.reload();
        } else {
            alert('è·å–é‚®ç®±ç´ æå¤±è´¥ï¼š' + data.message);
        }
    } catch (error) {
        // æ¢å¤æŒ‰é’®çŠ¶æ€
        if (event && event.target) {
            event.target.textContent = 'è·å–é‚®ç®±ç´ æ';
            event.target.disabled = false;
        }
        console.error('Error:', error);
        alert('è·å–é‚®ç®±ç´ æå¤±è´¥ï¼š' + error.message);
    }
}

</script>
{% endblock %}